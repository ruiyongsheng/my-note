### DOM 树： Javascirpt 是如何影响 DOM 树构建的？

#### 精选评论

1. css 不阻塞 dom 的生成

2. css 不阻塞 js 的加载，但是会阻塞 js 的执行

3. js 会阻塞 dom 的生成， 也就是会阻塞页面的渲染，那么css也有可能会阻塞页面的渲染。

   如果把 css 放在 文档的最后面加载执行， css 不会阻塞 dom 的生成，也不会阻塞js,但是浏览器在解析完 dom 后，要花费额外的时间来解析 css,而 不是在解析 dom 的时候，并行解析 css.

   并且浏览器会先渲染出一个没有样式的页面，等 css 加载完成后会再渲染成一个有样式的页面，页面会出现明显的闪动现象

   所以应该把 css 放在文档的 头部， 尽可能的提前加载 css; 把 js 放在文档的尾部，这样js 也不会阻塞页面的渲染，css 会和 js 并行解析，css 解析也尽可能的不去阻塞js 的执行，从而使页面尽快的渲染完成。

4. async ： 脚本并行加载，加载完成之后立即执行，执行时机不确定，仍有可能阻塞 HTML 解析， 执行时机在 load 事件派发之前

   defer: 脚本并行加载，等待 html 解析完成之后，按照加载顺序执行脚本，执行时机在 DOMContentLoaded 事件派发之前。

###  渲染流水线： css 如何影响首次加载时的白屏时间

想要缩短白屏时长，可以有以下策略：

-  通过内联 Javascript、内联 css 来移除这两种类型的文件下载，这样获取到 html 文件之后就可以直接开始渲染流程了
- 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 Js文件
- 还可以对一些不需要在解析 html 阶段使用的 js 文件标记上 async 或者 defer.
-  对于大的css文件，可以通过媒体查询属性，将其拆分为多个不同用途的 css 文件，这样只有在特定的场景下才会加载特定的 css 文件

### 分层和合成机制： 为什么css 动画比 js 高效

合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。

总结：

- 渲染引擎生成一帧图像有三种方式： 重排、重绘和合成。其中，重排和重绘都是在渲染进程的主进程上执行的，比较耗时；而合成操作则是在渲染进程的合成线程上执行的，执行速度快，且不占用主线程。
- 浏览器是怎么实现合成的？ 分层，分块和合成
- 使用 will-change 来优化动画或特效

### 页面性能： 如何系统的优化页面？

阻塞网页首次渲染的资源称为关键资源：

1.  关键资源的个数
2. 关键资源的大小
3. 请求关键资源需要多个 RTT （RTT 就是 这里的往返时延，它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延）
4. 通常一个 HTTP 的数据包在 14kb 左右

解决上述三项的方式：

- 减少关键资源的个数：css/js变成内联，加async/defer 变成 非关键资源
- 减小关键资源的大小： 压缩，移除注释
- 减少关键资源的RTT： 使用CDN

交互阶段：

1. 减少 js 脚本的执行时间
2. 避免强制同步布局（所谓强制同步布局，是指 js 强制将计算样式和布局操作提前到当前的任务中，让渲染引擎默认执行一次布局操作）
3. 避免布局抖动
4. 合理利用css 合成动画
5. 避免频繁的垃圾回收

