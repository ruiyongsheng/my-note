### 栈空间和堆空间： 数据是如何存储的？

Js的数据类型一种有八种

![image-20210303105312294](https://tva1.sinaimg.cn/large/a2f16a97ly1gp16q9mo04j20r20fk10m.jpg)

Javascript的内存模型： `代码空间、栈空间 和 堆空间 `

### 垃圾回收♻️

当一个函数执行结束后， **Javascript 引擎会向下移动 ESP （记录当前函数执行状态的指针）来销毁该函数保存在栈中的执行上下文**

要回收 堆中的垃圾数据，就需要用到 Javascript 中的垃圾回收器了

V8 引擎中会把 堆 分为 **新生代** 和 **老生代** 两个区域，新生代中存在的是生存时间短的对象，老生代中存在的生存时间久的对象。

- 新生代空间： 1—8 M 的容量， 副垃圾回收器，采用 Scavenge 算法来处理，分为 **对象区域** 和 **空闲区域** ，存在 **对象晋升策略**
- 老生代空间： 容量大的多，对象存活时间长， 主垃圾回收器，采用Mark-Sweep 的算法进行垃圾回收。mark-compact 算法
- 为了降低老生代的垃圾回收而造成的卡顿， v8 将标记过程分为一个个的字标记过程，同时让垃圾回收标记和 Javascript 应用逻辑交替运行，直到标记阶段完成，这个算法叫做 增量标记算法 （Incremental Marking）

#### 精选评论

#### 一、 垃圾回收策略一般分为`手动回收`和`自动回收`，java python JavaScript等高级预言为了减轻程序员负担和出错概率采用了自动回收策略。JavaScript的原始类型数据和引用数据是分别存储在栈和椎中的，由于栈和堆分配空间大小差异，垃圾回收方式也不一样。

1. 栈中分配空间通过`ESP的向下移动`销毁保存在栈中数据；
2. 堆中垃圾回收主要通过`副垃圾回收器（新生代）`和`主垃圾回收器（老生代）`负责的，副垃圾回收器采用`scavenge算法`将区域分为`对象区域`和`空闲区域`，通过两个区域的反转让新生代区域无限使用下去。
3. 主垃圾回收器采用Mark-Sweep（Mark-Compact, Incremental Marking解决不同场景下问题的算法改进）算法进行空间回收的。无论是主副垃圾回收器的策略都是标记-清除-整理三个大的步骤。另外还有新生代的晋升策略（两次未清除的），大对象直接分配在老生代。

#### 二、 栈和堆

栈垃圾回收
当函数执行结束，JS引擎通过向下移动ESP指针（记录调用栈当前执行状态的指针），来销毁该函数保存在栈中的执行上下文（变量环境、词法环境、this、outer）。

堆垃圾回收
一、代际假说
1、大部分对象存活时间很短
2、不被销毁的对象，会活的更久

二、分类
V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。

三、新生代
算法：Scavenge 算法
原理：
1、把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。
2、新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。
3、先对对象区域中的垃圾做标记，标记完成之后，把这些存活的对象复制到空闲区域中
4、完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。
对象晋升策略：
经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

四、老生代
算法：标记 - 清除（Mark-Sweep）算法
原理：
1、标记：标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。
2、清除：将垃圾数据进行清除。
碎片：
对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存。

算法：标记 - 整理（Mark-Compact）算法
原理：
1、标记：和标记 - 清除的标记过程一样，从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素标记为活动对象。
2、整理：让所有存活的对象都向内存的一端移动
3、清除：清理掉端边界以外的内存

优化算法：增量标记（Incremental Marking）算法
原理：
1、为了降低老生代的垃圾回收而造成的卡顿
2、V8把一个完整的垃圾回收任务拆分为很多小的任务
3、让垃圾回收标记和 JavaScript 应用逻辑交替进行



#### Javascript 是如何执行一段代码的

Babel 的工作原理是先将 ES6 源码转换为 AST, 然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST, 最后利用 ES5 的 AST 生成 Javascript 源代码。

生成AST 的过程： 先分词，再解析

![image-20210303144626897](https://tvax4.sinaimg.cn/large/a2f16a97ly1gp5g85267yj20t60b4goa.jpg)

V8 是如何执行一段 js 代码的：V8 依据 Js 代码生成 AST  和执行上下文，再基于 AST 生成字节码，通过编译器来优化编译字节码。

