### 同源策略：为什么XMLHttpRequest 不能跨域请求资源？

1.  页面中可以引用第三方资源，不过这暴露了许多诸如 XSS 的安全问题，因此又在这种开发的基础上引入了 CSP 来限制其自由程度
   CSP:  让服务器决定浏览能够加载哪些资源，让服务端决定浏览器是否能够执行内联 js 代码
2. 使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的，因此浏览器又在这种开放的基础之上引入了`跨域资源共享策略` (CORS)，让其可以安全的进行跨域操作
3. 两个不同源 的 DOM 是不能相互操作的，因此，浏览器又实现了 跨文档消息机制，让其可以比较安全的通信。

#### 跨站脚本攻击（xss）:  为什么 Cookie 中有 HttpOnly 属性？

阻止 xss 攻击的策略：

1. 服务器对输入脚本进行过滤或转码
2. 充分利用 CSP 
   - 限制健在其他域下的资源文件，这样即使黑客插入了一个 js 文件，这个 js 文件也是无法被加载的
   - 禁止向第三方域提交数据，这样用户的数据也不会外泄
   - 禁止执行内联脚本和未授权的脚本
   - 提供了上报机制，能尽早发现xss 攻击，以便快速修复问题
3. 使用 HttpOnly 属性



#### CSRF攻击： 陌生链接不要随便点

CSRT (Cross-site request forgery)   跨站请求伪造

CSRF  攻击就是黑客利用了用户的登录状态，并通过第三方的站点做些坏事

和 xss 不同的是， CSRF 攻击不需要将 恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户登录状态来实施攻击。

##### 如何防止 CSRF 攻击

1. 充分利用好 Cookie 的 SameSite 属性（在http 响应头中，通过set-cookie:Same-Site:none）
2. 验证请求的来源站点，server 优先判断 Origin，再去判断是否使用Referer 值
3. CSRF Token

### 安全沙箱： 页面和系统之间的隔离墙

- 安全沙箱是不能防止 XSS 或者 CSRF 一类的攻击，
- 安全沙箱的目的是隔离渲染进程和操作系统，让渲染进行没有访问操作系统的权利
- XSS 或者 CSRF 主要是利用网络资源获取用户的信息，这和操作系统没有关系的

### HTTPS: 让数据传输更安全

![image-20210305105316017](/Users/rys/Library/Application Support/typora-user-images/image-20210305105316017.png)

安全层： 对发起HTTP请求的数据进行加密操作 和 对接收到的 HTTP 内容进行解密操作

1. 首先是tcp的三次握手建立连接
2. client发送random1+支持的加密算法集合（clientHello）
3. server收到信息，返回选择一个加密算法+random2（serverHello）+ 证书+ 确认
4. client验证证书有效性，并用random1+random2生成pre-master通过服务器公钥加密 发送给server
5. server收到premaster，根据约定的加密算法对random1+random2+premaster（解密）生成master-secret，然后发送预定成功
6. client收到生成同样的master-secert，对称加密秘钥传输完毕

今日总结
浏览器安全主要包括页面安全、系统安全、传输安全三个部分。https主要保证传输过程的安全，从防止中间人窃取修改伪造的角度循序渐进的介绍了https的实现过程。

1. 对称加密传输（协商秘钥的过程容易被窃取）
2. 非对称加密传输（服务端用私钥加密的内容，可以通过它的公钥进行解密）
3. 非对称加密交换秘钥、对称加密传输内容（DNS劫持 如何保证服务器是可信的）
4. 引入CA权威机构保证服务器可信性。
   数字证书的申请过程：服务器生成一对公钥和私钥，私钥自己保存，通过公钥+企业+网站信息去CA机构申请证书。CA机构通过全方位的验证给这个网站颁发证书，证书内容包括企业信息、证书有效期、证书编号，以及自己私钥加密上述信息的摘要、网站的公钥。服务器就获得了CA的认证。
5. 浏览器认证证书过程：浏览器从服务器拿到网站的证书，通过CA的公钥解密证书信息的摘要跟使用摘要算法计算企业信息等的摘要对比，如果一致则证明证书有效。如果证书CA是可靠的呢，通过给CA颁发证书的根CA验证，通常操作系统中包括顶级CA证书（它们自己给自己签名称为自签名证书，我们自己生成证书也是自签名证书 只是它不是操作系统内置的）