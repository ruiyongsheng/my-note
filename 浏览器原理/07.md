### 作用域链和闭包和this

![image-20210302152622957](/Users/rys/Library/Application Support/typora-user-images/image-20210302152622957.png)

#### 词法作用域

词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能预测代码在执行过程中如何查找标识符。

![image-20210302152853057](/Users/rys/Library/Application Support/typora-user-images/image-20210302152853057.png)

词法作用域链的顺序是：**foo 函数作用域—>bar 函数作用域—>main 函数作用域—> 全局作用域。**

#### 闭包

在 js中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合成为闭包。比如外部函数是foo，那么这些变量的集合就称为 foo 函数的闭包。

![image-20210302174331700](/Users/rys/Library/Application Support/typora-user-images/image-20210302174331700.png)

从 ‘Local => Closure(foo) => Global’ 就是一个完整的作用域链

#### 闭包是怎么回收的

如果该闭包会一直使用，那么它可以作为全局变量而存在；但是如果使用频率不搞，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。

#### 从 js 执行上下文的视角讲清楚 this

- 在全局环境中调用一个函数，函数内部的 this 指向全局变量 window
- 通过一个对象来调用其内部的一个方法，该方法的执行上下文中的this 指向对象本身。

规律总结：

1. 当函数作为对象的方法调用时，函数中的 this就是该对象；
2. 当函数被正常调用时，在严格模式下，this的值是 undefined,非严格模式下 this 指向的是全局对象 window
3. 嵌套函数中的 this 不会继承外层函数的 this 值
4. 箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this;
