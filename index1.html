<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>手写js</title>
</head>
<style>
  html,
  body {
    width: 100%;
    height: 100%;
  }
</style>

<body>
  <script>
    // 1. 手写call
    /*
      1. 改变this指向
      2. 执行这个方法
      3. 参数以可变参数形式传递
    */
    Function.prototype.myCall = function (context, ...args) {
      if (this === Function.prototype) {
        return undefined;
      }
      var context = context || window;
      var fn = Symbol();
      context[fn] = this;
      let res = context[fn](...args);
      delete context.fn;
      return res;
    }
    Function.prototype.myApply = function (context, arr) {
      if (this === Function.prototype) {
        return undefined;
      }
      var context = context || window;
      var fn = Symbol();
      context[fn] = this;
      let res;
      if (Array.isArray(arr)) {
        res = context[fn](...arr);
      } else {
        res = context[fn]();
      }
      delete context.fn;
      return res;
    }

    Function.prototype.myBind = function (context, ...args1) {
      if (this === Function.prototype) {
        throw new TypeError('Error');
      }
      let self = this;
      return function F(...args2) {
        let res;
        if (this instanceof F) {
          res = new self(...args1, ...args2);
        } else {
          res = self.apply(context, args1.concat(args2));
        }
        return res;
      }
    }
    // 2. 防抖
    /*
      1. 为了解决事件频繁触发，节约性能
      常见事件 scroll,resize,mouse-events
    */
    function debounce(fn, delay, immediate) {
      // 利用了闭包
      let timer = null;
      return function () {
        timer && clearTimeout(timer);
        if (immediate) {
          let callNow = !timer;

          timer = setTimeout(() => {
            timer = null;
          }, delay);

          if (callNow) {
            fn.apply(this, arguments);
          }
        } else {
          timer = setTimeout(() => {
            fn.apply(this, arguments);
          }, delay)
        }

      }
    }
    function debounce1(event, time, flag) {
      let timer = null;
      return function (...args) {
        clearTimeout(timer);
        (flag && !timer) && event.apply(this, args);
        timer = setTimeout(() => {
          flag ? (timer = null) : event.apply(this, args);
        }, time);
      };
    }

    let n = 0;
    function bodyClick() {
      console.log(++n);
    }
    // document.body.onclick = debounce1(bodyClick, 300, true);

    // 节流
    function Throttle(fn, delay) {
      let start = 0;
      return function () {
        let end = Date.now();
        if (end - start >= delay) {
          fn.apply(this, arguments);
          start = end;
        }
      }
    }
    // 数组扁平化
    // 1. arr.toString() 2. 递归 3. 字符串替换 4. concat + some + while  5. flat(Infinity);

    // 数组乱序，又叫洗牌算法
    function mixArr (arr) {
      return arr.sort(() => {
          return Math.random() - 0.5;
        }
      )
    }
    // 费耶斯排序
    function feiyesi (arr) {
      let length = arr.length;
      while (length > 1) {
        let index = parseInt(Math.random() * length--);
        [arr[index], arr[length]] = [arr[length], arr[index]]
      }
      return arr;
    }

    document.body.onclick = Throttle(bodyClick, 3000);
  </script>

</body>

</html>